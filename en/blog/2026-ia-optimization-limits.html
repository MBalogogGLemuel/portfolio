<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-01-29">

<title>Why Optimization Problems Expose the Limits of AI Reasoning – Georges Lemuel Balogog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const path = window.location.pathname;

    const frUrl = path.replace("/portfolio/en/", "/portfolio/fr/");
    const enUrl = path; // already EN

    const links = Array.from(document.querySelectorAll(".navbar a.nav-link"));
    const frLink = links.find(a => a.textContent.trim() === "FR");
    const enLink = links.find(a => a.textContent.trim() === "EN");

    if (frLink) frLink.setAttribute("href", frUrl);
    if (enLink) enLink.setAttribute("href", enUrl);
  });
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Georges Lemuel Balogog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-blog" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Blog</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-blog">    
        <li>
    <a class="dropdown-item" href="../blog/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/2026-ia-illusion-thinking.html">
 <span class="dropdown-text">IA Illusion of Thought</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/2026-ia-optimization-limits.html">
 <span class="dropdown-text">IA Limits of Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/feasibility-over-optimality.html">
 <span class="dropdown-text">Why Feasibility Matters More Than Optimality</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../#"> 
<span class="menu-text">FR</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../#"> 
<span class="menu-text">EN</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/MBalogogGLemuel"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/balogog-georges-6810b9118/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:georges.balogog@yahoo.fr"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Why Optimization Problems Expose the Limits of AI Reasoning</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 29, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="justify">
<p><img src="../../assets/blog/img2.png" class="img-fluid" style="width:50.0%"></p>
<section id="introduction-the-unforgiving-test" class="level2">
<h2 class="anchored" data-anchor-id="introduction-the-unforgiving-test">Introduction: The Unforgiving Test</h2>
<p>If you want to understand the true limits of AI reasoning, don’t ask it to write poetry or summarize articles.</p>
<p><strong>Ask it to design an optimization model.</strong></p>
<p>Not generate code for a textbook example. Not reproduce a standard formulation from a paper. But actually <strong>design</strong> a model for a messy, real-world operational problem with competing objectives, hard constraints, and no clear precedent.</p>
<p>Watch it fail—fluently, confidently, convincingly—in ways that won’t become obvious until you try to solve the model at scale or deploy it in production.</p>
<p>I’ve debugged enough AI-generated optimization models to recognize a pattern: <strong>AI excels at prediction, but struggles fundamentally with prescription</strong>. And optimization is the ultimate test of prescriptive reasoning.</p>
<p>Here’s why.</p>
<hr>
</section>
<section id="optimization-is-not-prediction" class="level2">
<h2 class="anchored" data-anchor-id="optimization-is-not-prediction">Optimization is not prediction</h2>
<p>Most successes of modern AI come from <strong>prediction problems</strong>: classification, regression, pattern completion, sequence generation.</p>
<p>These are fundamentally <strong>probabilistic</strong> tasks. They ask:</p>
<ul>
<li><em>What is likely given the data?</em></li>
<li><em>What pattern best fits this distribution?</em></li>
<li><em>What comes next in this sequence?</em></li>
</ul>
<p>Optimization problems are <strong>categorically different</strong>. They are not about <em>what is likely</em>, but about <em>what is allowed</em> and <em>what is best within those boundaries</em>.</p>
<p><strong>The shift is profound:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Prediction</strong></th>
<th><strong>Optimization</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Minimize expected error</td>
<td>Maximize/minimize objective <em>subject to constraints</em></td>
</tr>
<tr class="even">
<td>Probabilistic correctness</td>
<td>Absolute feasibility requirement</td>
</tr>
<tr class="odd">
<td>Approximation is acceptable</td>
<td>Infeasibility is catastrophic</td>
</tr>
<tr class="even">
<td>Gradient descent, backprop</td>
<td>Combinatorial search, branch-and-bound</td>
</tr>
<tr class="odd">
<td>Performance degrades gracefully</td>
<td>Performance collapses at constraint violation</td>
</tr>
</tbody>
</table>
<p>In prediction, being 95% accurate is often excellent.<br>
In optimization, a solution that violates even one hard constraint is <strong>worthless</strong>—worse than no solution at all, because it creates false confidence.</p>
<p><strong>Feasibility comes before performance.</strong></p>
<p>AI systems trained on prediction tasks don’t internalize this. They’ve learned to approximate, to generalize, to find “good enough” patterns. Optimization doesn’t care about “good enough” when it comes to constraints. It demands <strong>exact compliance</strong>.</p>
<hr>
</section>
<section id="constraints-are-not-suggestions" class="level2">
<h2 class="anchored" data-anchor-id="constraints-are-not-suggestions">Constraints are not suggestions</h2>
<p>In optimization, constraints are <strong>absolute</strong>. Violating one constraint invalidates the entire solution.</p>
<p>Consider a real example from my work in warehouse optimization:</p>
<ul>
<li><em>“Each SKU must be assigned to exactly one location”</em> → Hard constraint. Not negotiable.</li>
<li><em>“High-turnover items should be near packing stations”</em> → Soft preference. Optimizable.</li>
</ul>
<p>An AI system often cannot reliably distinguish these.</p>
<section id="how-ai-systems-fail-with-constraints" class="level3">
<h3 class="anchored" data-anchor-id="how-ai-systems-fail-with-constraints">How AI systems fail with constraints:</h3>
<p><strong>1. Softening constraints unintentionally</strong></p>
<p>AI will see patterns where hard constraints were relaxed in training data (for tractability, simplification, or specific use cases) and <strong>generalize that relaxation inappropriately</strong>.</p>
<p>Example: A model trained on academic benchmarks where capacity constraints were relaxed to “at most 110% of nominal capacity” will propose the same relaxation for a production system where exceeding physical capacity means <strong>literal overflow, equipment damage, or regulatory violations</strong>.</p>
<p><strong>2. Confusing penalties with guarantees</strong></p>
<p>AI frequently suggests penalty-based formulations for hard constraints:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># objective function with penalty for constraint violation</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>objective <span class="op">=</span> minimize(cost <span class="op">+</span> <span class="dv">1000</span> <span class="op">*</span> constraint_violation)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This looks plausible. It even works—sometimes.</p>
<p>But it’s fundamentally wrong for a hard constraint. The penalty coefficient (1000) is arbitrary. If the cost savings from violating the constraint exceed 1000, the solver will <strong>happily violate it</strong>. You’ve turned an absolute requirement into a negotiable trade-off.</p>
<p>A human optimizer knows: <strong>hard constraints belong in the constraint set, not the objective function</strong>.</p>
<p><strong>3. Optimizing objectives while breaking feasibility</strong></p>
<p>I’ve seen AI-generated models that beautifully minimize transportation costs while quietly violating:</p>
<ul>
<li>Precedence constraints (pickup before delivery),</li>
<li>Time windows (deliveries after customer closing),</li>
<li>Resource limits (vehicles carrying more than capacity).</li>
</ul>
<p>The objective improves. The KPIs look great. The solution is <strong>operationally impossible</strong>.</p>
</section>
<section id="humans-think-in-invariants" class="level3">
<h3 class="anchored" data-anchor-id="humans-think-in-invariants">Humans think in invariants</h3>
<p>When I design an optimization model, I start with <strong>invariants</strong>—conditions that must hold regardless of the objective value:</p>
<ul>
<li>Mass balance: <em>what goes in must equal what comes out</em>,</li>
<li>Logical precedence: <em>you cannot consume inventory before receiving it</em>,</li>
<li>Physical limits: <em>capacity, speed, throughput ceilings</em>.</li>
</ul>
<p>These aren’t optimization variables. They’re <strong>boundary conditions of reality</strong>.</p>
<p>AI doesn’t reason about invariants. It pattern-matches formulations that superficially resemble the problem, without understanding which elements are negotiable and which are non-negotiable.</p>
<hr>
</section>
</section>
<section id="the-combinatorial-explosion-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-combinatorial-explosion-problem">The combinatorial explosion problem</h2>
<p>Optimization models live in <strong>discrete spaces</strong>. Small modeling choices create <strong>exponential consequences</strong>.</p>
<p>Choosing whether a variable is:</p>
<ul>
<li><strong>Binary or continuous</strong> → Binary: enables logical constraints but explodes search space; Continuous: faster to solve but may require rounding heuristics,</li>
<li><strong>Indexed by time or aggregated</strong> → Time-indexed: captures dynamics but multiplies decision variables; Aggregated: compact but loses temporal resolution,</li>
<li><strong>Local or global</strong> → Local subproblems: decomposable, parallelizable; Global: guarantees optimality but may be intractable.</li>
</ul>
<p>Each decision fundamentally reshapes the <strong>computational geometry</strong> of the problem.</p>
<section id="a-concrete-example-production-scheduling" class="level3">
<h3 class="anchored" data-anchor-id="a-concrete-example-production-scheduling">A concrete example: production scheduling</h3>
<p><strong>Formulation A (time-indexed binary variables):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>x[product, machine, hour] ∈ {<span class="dv">0</span>,<span class="dv">1</span>}  <span class="co"># Binary assignment</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>100 products × 10 machines × 168 hours/week = <strong>168,000 binary variables</strong></li>
<li>Solver runtime: potentially hours or days</li>
<li>Solution quality: potentially optimal</li>
</ul>
<p><strong>Formulation B (aggregated continuous variables with sequencing):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>y[product, machine] ∈ ℝ<span class="op">+</span>  <span class="co"># Continuous production quantity</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>z[product_i, product_j, machine] ∈ {<span class="dv">0</span>,<span class="dv">1</span>}  <span class="co"># Sequencing</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>100×10 continuous + 100×99×10 binary sequencing variables = <strong>100,000 variables</strong></li>
<li>Solver runtime: potentially minutes</li>
<li>Solution quality: optimal within aggregated time structure</li>
</ul>
<p>Same problem. Different modeling choices. <strong>Orders of magnitude difference in solve time</strong>.</p>
<p>A human optimizer makes this choice based on: - Decision frequency (hourly precision needed?), - Problem scale (can we afford 168k binaries?), - Operational constraints (are setups sequence-dependent?), - Solver capabilities (CPLEX, Gurobi, open-source?).</p>
<p><strong>AI systems do not reason about computational geometry.</strong></p>
<p>They’ve seen both formulations in training data. They’ll suggest one—possibly the wrong one—without understanding the computational consequences. They don’t think:</p>
<ul>
<li><em>“This problem instance has 50,000 SKUs; time-indexed binaries will never solve.”</em></li>
<li><em>“Aggregation will lose critical sequencing information for this use case.”</em></li>
</ul>
<p>They replay patterns that worked elsewhere, agnostic to scale, solver architecture, or operational context.</p>
<hr>
</section>
</section>
<section id="where-ai-helps-and-where-it-does-not" class="level2">
<h2 class="anchored" data-anchor-id="where-ai-helps-and-where-it-does-not">Where AI helps — and where it does not</h2>
<p>Let me be precise about where AI adds value in optimization work—and where it becomes a liability.</p>
<section id="where-ai-is-genuinely-useful" class="level3">
<h3 class="anchored" data-anchor-id="where-ai-is-genuinely-useful">✅ Where AI is genuinely useful:</h3>
<p><strong>1. Generating initial formulations</strong> Starting from a verbal problem description, AI can scaffold a baseline mathematical model—variables, objective, basic constraints. This accelerates the drafting phase, especially for standard problem types (shortest path, knapsack, assignment).</p>
<p><strong>2. Suggesting alternative constraint formulations</strong> Given a constraint in one form, AI can propose equivalent reformulations:</p>
<ul>
<li>Big-M constraints → Indicator constraints</li>
<li>Quadratic penalties → Piecewise linear approximations</li>
<li>Logical implications → Disjunctive constraints</li>
</ul>
<p>This is valuable for exploring tractability trade-offs.</p>
<p><strong>3. Exploring modeling variants</strong> AI can rapidly generate multiple versions of a model with different assumptions, helping you understand the sensitivity of the formulation to structural choices.</p>
<p><strong>4. Documentation and explanation</strong> Translating mathematical notation into plain language for stakeholders, generating solver configuration docs, explaining dual variables and shadow prices—AI excels here.</p>
</section>
<section id="where-ai-is-fundamentally-unreliable" class="level3">
<h3 class="anchored" data-anchor-id="where-ai-is-fundamentally-unreliable">❌ Where AI is fundamentally unreliable:</h3>
<p><strong>1. Deciding decomposition strategies</strong> Should you decompose this supply chain optimization into:</p>
<ul>
<li>Geography-based subproblems?</li>
<li>Time-rolling horizons?</li>
<li>Product family clusters?</li>
</ul>
<p>This requires understanding problem structure, coupling strength, and recourse decisions. AI cannot reliably reason about this—it will suggest decompositions that worked in training examples without validating applicability.</p>
<p><strong>2. Guaranteeing feasibility under operational stress</strong> What happens when:</p>
<ul>
<li>Demand spikes 200% above forecast?</li>
<li>A key supplier goes offline?</li>
<li>Regulatory constraints change mid-horizon?</li>
</ul>
<p>AI-generated models often validate on historical data but fail catastrophically on edge cases they haven’t seen. <strong>Stress-testing formulations requires adversarial thinking</strong>—anticipating failures, not just fitting patterns.</p>
<p><strong>3. Designing KPIs aligned with operations</strong> Minimizing total cost is not the same as minimizing cost volatility.<br>
Maximizing throughput is not the same as maximizing throughput stability.<br>
Reducing inventory is not the same as reducing stockout risk.</p>
<p><strong>Choosing the right objective function requires operational intuition</strong>—understanding what stakeholders actually care about, what metrics drive behavior, and what unintended consequences might emerge. AI doesn’t have stakeholders. It doesn’t own P&amp;L. It optimizes what it’s told to optimize, even if it’s the wrong thing.</p>
<hr>
</section>
</section>
<section id="a-warning-for-practitioners" class="level2">
<h2 class="anchored" data-anchor-id="a-warning-for-practitioners">A warning for practitioners</h2>
<p>I’ve seen this pattern too many times:</p>
<ol type="1">
<li>Business problem arrives → “Let’s use AI to design the optimization model”</li>
<li>AI generates a plausible-looking formulation → Team assumes it’s correct</li>
<li>Implementation begins → Code works, solver runs, outputs generated</li>
<li>Deployment → Model fails in production (infeasibility, poor performance, wrong KPIs)</li>
<li>Debugging → Weeks spent untangling assumptions embedded in AI-generated structure</li>
</ol>
<p><strong>Blind trust in AI-assisted optimization leads to:</strong></p>
<ul>
<li><strong>Brittle models</strong> that work on average but fail on edge cases,</li>
<li><strong>Opaque assumptions</strong> that no one validated because “the AI generated it”,</li>
<li><strong>False confidence</strong> because the model produces numbers—even if they’re operationally meaningless.</li>
</ul>
<section id="the-insidious-part" class="level3">
<h3 class="anchored" data-anchor-id="the-insidious-part">The insidious part:</h3>
<p>Poor optimization models don’t fail with error messages.<br>
They fail by <strong>silently producing suboptimal or infeasible recommendations</strong> that degrade performance over time.</p>
<p>You don’t get a stack trace.<br>
You get declining KPIs, frustrated stakeholders, and a slow erosion of trust in analytics.</p>
<p><strong>Optimization rewards humility.</strong></p>
<p>It demands that you question every assumption, validate every constraint, stress-test every edge case.</p>
<p><strong>AI currently does not have humility.</strong></p>
<p>It produces formulations with confidence inversely proportional to its actual understanding.</p>
<hr>
</section>
</section>
<section id="final-thoughts-the-test-of-prescriptive-reasoning" class="level2">
<h2 class="anchored" data-anchor-id="final-thoughts-the-test-of-prescriptive-reasoning">Final thoughts: The test of prescriptive reasoning</h2>
<p>Optimization problems are <strong>unforgiving</strong>.</p>
<p>They expose the difference between:</p>
<ul>
<li><strong>Appearance of intelligence</strong> (fluent explanations, plausible formulations),</li>
<li>And <strong>commitment to correctness</strong> (absolute feasibility, validated assumptions, operational accountability).</li>
</ul>
<p>Prediction tasks allow graceful degradation. Get 95% of classifications right, and you’re doing well.</p>
<p>Optimization tasks are <strong>binary in outcomes</strong>: either your solution is feasible and improves operations, or it’s not and you’ve wasted effort.</p>
<p>There’s no middle ground.</p>
<p><strong>This is why optimization is the ultimate test for AI reasoning.</strong></p>
<p>It requires:</p>
<ul>
<li>Understanding <strong>invariants</strong> (non-negotiable constraints),</li>
<li>Reasoning about <strong>computational complexity</strong> (tractability vs.&nbsp;optimality trade-offs),</li>
<li>Managing <strong>discrete spaces</strong> (combinatorial explosion),</li>
<li>Validating <strong>edge cases</strong> (adversarial stress-testing),</li>
<li>Aligning <strong>mathematical objectives with operational reality</strong>.</li>
</ul>
<p>Current AI systems can simulate competence on the first pass.<br>
They cannot sustain it under scrutiny.</p>
<p><strong>Until AI can reason under constraints—truly reason, not pattern-match—it will remain an assistant, not a designer.</strong></p>
<hr>
</section>
<section id="where-does-this-leave-us" class="level2">
<h2 class="anchored" data-anchor-id="where-does-this-leave-us">Where does this leave us?</h2>
<p>I use AI extensively in my optimization work.<br>
But I <strong>never</strong> delegate model design to it.</p>
<p>I use it to:</p>
<ul>
<li>Accelerate formulation drafting,</li>
<li>Explore alternative structures,</li>
<li>Generate solver configurations and documentation.</li>
</ul>
<p>I do <strong>not</strong> use it to:</p>
<ul>
<li>Make foundational modeling decisions,</li>
<li>Choose decomposition strategies,</li>
<li>Validate feasibility under operational stress,</li>
<li>Define objectives aligned with business reality.</li>
</ul>
<p><strong>The final responsibility—the commitment to deploy—remains human.</strong></p>
<p>Because when the model fails in production, <strong>I</strong> own that failure.<br>
And I cannot outsource accountability to a statistical approximator.</p>
<hr>
<p><em>In optimization, elegance is optional.<br>
Feasibility is not.</em></p>
<p><em>And until AI understands the difference,<br>
the hardest decisions must remain ours.</em></p>
<hr>
<p><strong>Have you deployed AI-assisted optimization models?</strong> What worked? What failed spectacularly? I’d love to hear war stories—reach out on <a href="https://www.linkedin.com/in/balogog-georges-6810b9118/">LinkedIn</a>.</p>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mbalogogglemuel\.github\.io\/portfolio\/en\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>