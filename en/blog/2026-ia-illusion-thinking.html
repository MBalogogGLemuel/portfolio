<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-01-28">

<title>Can AI Really Think About Model Design? – Georges Lemuel Balogog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const path = window.location.pathname;

    const frUrl = path.replace("/portfolio/en/", "/portfolio/fr/");
    const enUrl = path; // already EN

    const links = Array.from(document.querySelectorAll(".navbar a.nav-link"));
    const frLink = links.find(a => a.textContent.trim() === "FR");
    const enLink = links.find(a => a.textContent.trim() === "EN");

    if (frLink) frLink.setAttribute("href", frUrl);
    if (enLink) enLink.setAttribute("href", enUrl);
  });
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Georges Lemuel Balogog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-blog" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Blog</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-blog">    
        <li>
    <a class="dropdown-item" href="../blog/index.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/2026-ia-illusion-thinking.html">
 <span class="dropdown-text">IA Illusion of Thought</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/2026-ia-optimization-limits.html">
 <span class="dropdown-text">IA Limits of Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../blog/feasibility-over-optimality.html">
 <span class="dropdown-text">Why Feasibility Matters More Than Optimality</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../#"> 
<span class="menu-text">FR</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../#"> 
<span class="menu-text">EN</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/MBalogogGLemuel"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/balogog-georges-6810b9118/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:georges.balogog@yahoo.fr"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Can AI Really Think About Model Design?</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 28, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="justify">
<p><img src="../../assets/blog/img1.png" class="img-fluid" style="width:50.0%"></p>
<p>Recent advances in large language models have reignited an old question: <em>can machines truly reason, or do they merely reproduce convincing patterns?</em></p>
<p>In applied data science and optimization, this question is not philosophical. It becomes <strong>practical and painful</strong> as soon as we ask AI systems to assist in <strong>model design</strong>, not just code generation.</p>
<p>I’ve spent years designing optimization models for supply chains, energy systems, and operational planning. I’ve watched AI systems generate impressively fluent formulations—and I’ve also debugged the silent failures they create when deployed. This post is about the gap between <strong>what AI can articulate</strong> and <strong>what it can actually understand</strong>.</p>
<hr>
<section id="fluency-is-not-understanding" class="level2">
<h2 class="anchored" data-anchor-id="fluency-is-not-understanding">Fluency is not understanding</h2>
<p>Modern AI systems are remarkably fluent. They can describe optimization models, recite textbook formulations, and even generate plausible mathematical expressions with impressive syntax.</p>
<p>What they cannot reliably do is <strong>decide why a model should be designed one way rather than another</strong>.</p>
<p>They often fail to distinguish between: - a theoretically elegant formulation, - a computationally feasible one, - and an operationally usable one.</p>
<p><strong>Example from practice:</strong><br>
Ask an AI to design a warehouse slotting optimization model. It will confidently propose a Mixed-Integer Linear Program (MILP) with binary variables for every SKU-location pair. Mathematically correct. Computationally catastrophic at scale—thousands of products, hundreds of locations, and solver runtimes exploding into hours or days.</p>
<p>A human optimizer would immediately ask: - <em>Can we decompose this by zone?</em> - <em>Should we relax some integer constraints?</em> - <em>What’s the real decision frequency—daily, weekly, quarterly?</em></p>
<p>These questions don’t come from pattern matching. They come from <strong>operational intuition forged through failure and iteration</strong>.</p>
<p>This distinction is precisely where human expertise matters.</p>
<hr>
</section>
<section id="model-design-is-a-sequence-of-commitments" class="level2">
<h2 class="anchored" data-anchor-id="model-design-is-a-sequence-of-commitments">Model design is a sequence of commitments</h2>
<p>Designing a model is not about choosing equations. It is about <strong>committing to assumptions</strong>—each one a negotiation between competing objectives.</p>
<p>When I decide to: - <strong>linearize a constraint</strong> → I’m choosing computational tractability over perfect realism, - <strong>split a global optimization into sequential subproblems</strong> → I’m accepting local optima to guarantee convergence, - <strong>introduce a penalty instead of a hard constraint</strong> → I’m prioritizing solution existence over strict compliance.</p>
<p>Each decision carries consequences: - Linearization may ignore critical non-linear interactions. - Decomposition may miss globally optimal solutions. - Penalties require careful tuning—too weak and they’re ignored; too strong and they dominate the objective.</p>
<p>I am not optimizing mathematics.<br>
I am negotiating <strong>trade-offs between realism, tractability, and stability</strong>.</p>
<p>Current AI systems do not <em>understand</em> these trade-offs.<br>
They imitate them. They’ve seen similar patterns in training data. But when faced with a novel operational context—<strong>a new constraint structure, an unusual cost function, a hybrid discrete-continuous problem</strong>—they regress to textbook templates that may be fundamentally unsuited to the problem at hand.</p>
<hr>
</section>
<section id="why-this-matters-in-practice" class="level2">
<h2 class="anchored" data-anchor-id="why-this-matters-in-practice">Why this matters in practice</h2>
<p>In real projects, poor model design does not fail loudly.<br>
It fails <strong>silently, insidiously, expensively</strong>.</p>
<section id="silent-failure-modes-ive-encountered" class="level3">
<h3 class="anchored" data-anchor-id="silent-failure-modes-ive-encountered">Silent failure modes I’ve encountered:</h3>
<p><strong>1. Infeasibility that appears only in production</strong><br>
A model validates perfectly on historical data. Deploy it with real-time inputs, and suddenly: <em>“No feasible solution found.”</em> Why? Because the AI-generated formulation didn’t account for operational constraints that rarely appear in training scenarios—equipment downtime, simultaneous resource conflicts, regulatory edge cases.</p>
<p><strong>2. Numerical instability at scale</strong><br>
A small-scale pilot works beautifully. Scale to production data volumes, and solver performance collapses. The culprit? Poor constraint formulation leading to ill-conditioned matrices, numerical precision issues, or combinatorial explosion that wasn’t visible at toy scale.</p>
<p><strong>3. KPIs improve in simulation but degrade operations</strong><br>
The model optimizes the <em>wrong</em> objective. It minimizes total distance traveled but ignores picking time variability. It maximizes throughput but creates bottlenecks downstream. It reduces inventory costs but increases stockout risk beyond acceptable thresholds.</p>
<p><strong>AI-generated designs often look correct until confronted with reality.</strong></p>
<p>The model runs. It produces numbers. It generates convincing dashboards.<br>
But the <strong>assumptions embedded in its structure</strong> don’t reflect the operational reality it was meant to serve.</p>
<p>And here’s the insidious part: <strong>the business user won’t know</strong>. They see charts, metrics, recommendations. They don’t see the linearization that discarded a critical interaction, the penalty coefficient chosen arbitrarily, or the decomposition that locked out better solutions.</p>
<hr>
</section>
</section>
<section id="what-ai-can-do-well" class="level2">
<h2 class="anchored" data-anchor-id="what-ai-can-do-well">What AI <em>can</em> do well</h2>
<p>Let’s be clear: I use AI extensively in my work. It’s not about AI versus humans.<br>
It’s about <strong>knowing where AI excels and where it fails</strong>.</p>
<p><strong>AI is a powerful assistant for:</strong></p>
<ul>
<li><strong>Exploration:</strong> Rapidly generating candidate formulations, testing alternative objective functions, exploring sensitivity to parameters.</li>
<li><strong>Documentation:</strong> Translating mathematical notation into plain language, generating solver configuration documentation, explaining model structure to non-technical stakeholders.</li>
<li><strong>Code acceleration:</strong> Implementing standard algorithms (Simplex, Branch-and-Bound, gradient descent), generating boilerplate for data ingestion and transformation, scaffolding MLOps pipelines.</li>
</ul>
<p>But when it comes to <strong>model architecture</strong>—the fundamental decisions about what to optimize, what to constrain, and how to balance competing objectives—<strong>that requires judgment born from experience, failure, and accountability</strong>.</p>
<hr>
</section>
<section id="the-accountability-gap" class="level2">
<h2 class="anchored" data-anchor-id="the-accountability-gap">The accountability gap</h2>
<p>Here’s the core issue: <strong>AI cannot be held accountable</strong>.</p>
<p>When a model I design fails in production, I own that failure.<br>
I debug it. I iterate. I explain to stakeholders what went wrong and how we’ll fix it.<br>
I carry the operational consequences of my assumptions.</p>
<p>When an AI-generated model fails, who owns it?<br>
The data scientist who deployed it without validating assumptions?<br>
The AI system that “hallucinated” a plausible-looking formulation?</p>
<p><strong>Responsibility cannot be delegated to a statistical pattern matcher.</strong></p>
<p>Model design is fundamentally about <strong>risk management</strong>—understanding what can go wrong, anticipating edge cases, stress-testing assumptions against operational reality.</p>
<p>AI can simulate competence.<br>
It cannot simulate accountability.</p>
<hr>
</section>
<section id="conclusion-tools-not-replacements" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-tools-not-replacements">Conclusion: Tools, not replacements</h2>
<p>AI is a <strong>force multiplier</strong> for experienced practitioners.<br>
It is a <strong>dangerous crutch</strong> for those who don’t yet understand the domain.</p>
<p>I use AI to:</p>
<ul>
<li>Accelerate implementation of well-understood patterns,</li>
<li>Explore formulation alternatives quickly,</li>
<li>Document and communicate model logic.</li>
</ul>
<p>I do <strong>not</strong> use AI to:</p>
<ul>
<li>Make foundational design decisions,</li>
<li>Choose between competing modeling paradigms,</li>
<li>Validate whether a model is fit for operational deployment.</li>
</ul>
<p><strong>Model design remains a human responsibility.</strong></p>
<p>Not because humans are faster.<br>
Not because humans are more creative.</p>
<p>But because <strong>we are accountable for assumptions</strong>.</p>
<p>We understand that every model is a <strong>deliberate simplification of reality</strong>.<br>
We know which simplifications are acceptable and which are catastrophic.<br>
We can explain our choices, defend our trade-offs, and adapt when reality proves us wrong.</p>
<hr>
<p><em>AI can write models.<br>
It cannot yet take responsibility for them.</em></p>
<p><em>And until it can, the final decision—the commitment to deploy, the ownership of outcomes—must remain human.</em></p>
<hr>
<p><strong>What’s your experience?</strong> Have you deployed AI-generated models in production? What failed? What worked? I’d love to hear your stories—reach out on <a href="https://www.linkedin.com/in/balogog-georges-6810b9118/">LinkedIn</a>.</p>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mbalogogglemuel\.github\.io\/portfolio\/en\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>